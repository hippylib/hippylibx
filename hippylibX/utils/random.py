import numpy as np
import dolfinx as dlx
import petsc4py

class parRandom():
    def __init__(self, comm):
        #All the seeding of the random number generator should 
        #happen once for all in the init method.
        rank = comm.rank
        nproc = comm.size

        master_seed = 123
        seed_sequence = np.random.SeedSequence(master_seed)

        child_seeds = seed_sequence.spawn(nproc)
        self.rng = np.random.MT19937(child_seeds[rank])

    def normal(self,sigma, out):
        # help(self)
        # num_local_values = d.array.shape[0]
        num_local_values = out.index_map.size_local + out.index_map.num_ghosts
        loc_random_numbers = np.random.default_rng(self.rng).normal(loc=0,scale= np.sqrt(sigma),size=num_local_values)
        out.array[:] = loc_random_numbers
        dlx.la.create_petsc_vector_wrap(out).ghostUpdate(petsc4py.PETSc.InsertMode.INSERT,petsc4py.PETSc.ScatterMode.FORWARD)

    def normal_perturb(self,sigma, out):
        # num_local_values = d.array.shape[0]
        num_local_values = out.index_map.size_local + out.index_map.num_ghosts
        loc_random_numbers = np.random.default_rng(self.rng).normal(loc=0,scale= np.sqrt(sigma),size=num_local_values)
        out.array[:] += loc_random_numbers
        dlx.la.create_petsc_vector_wrap(out).ghostUpdate(petsc4py.PETSc.InsertMode.INSERT,petsc4py.PETSc.ScatterMode.FORWARD)


# def parRandom(comm,noise_variance,d,addv=True):
#     """
#     comm -> communicator
#     noise_variance -> the variance of the normal distribution used to perturb the vector associated with the function d
#     d -> this vector will be perturbed with the noise #petsc4py.PETSc.Vec object
#     addv -> True if perturb, False if insert
#     """

#     rank = comm.rank
#     nproc = comm.size

#     num_local_values = d.index_map.size_local + d.index_map.num_ghosts

#     master_seed = 123
#     seed_sequence = np.random.SeedSequence(master_seed)


#     child_seeds = seed_sequence.spawn(nproc)
#     rng = np.random.MT19937(child_seeds[rank])

#     loc_random_numbers = np.random.default_rng(rng).normal(loc=0,scale= np.sqrt(noise_variance),size=num_local_values)
    
#     if(addv):
#         d.array[:] += loc_random_numbers
#     else:
#         d.array[:] = loc_random_numbers
        
#     dlx.la.create_petsc_vector_wrap(d).ghostUpdate(petsc4py.PETSc.InsertMode.INSERT,petsc4py.PETSc.ScatterMode.FORWARD)

##########################


    # rank  = comm.rank
    # nproc = comm.size

    # glb_num_vals = d.getSize()
    
    # #setting seed value
    # master_seed = 123
    # seed_sequence = np.random.SeedSequence(master_seed)
    
    # #Assigning seeds to each process
    # child_seeds = seed_sequence.spawn(nproc)
    # rng = np.random.MT19937(child_seeds[rank])
    
    # #number of random values that most processes is expected to generate
    # # and assign to d 
    # #glb_num_vals/nproc + 1 values will be generated by (glb_num_vals % nproc) processes
    # #glb_num_vals/nproc values will be generated by the remaning (glb_num_vals/nproc - glb_num_vals%nproc) processes.

    # loc_size = glb_num_vals//nproc
    # num_procs_type1 = glb_num_vals%nproc 

    # if(rank < num_procs_type1):
    #     loc_size += 1
    #     lower_index = rank * loc_size
    #     upper_index = (rank + 1)*loc_size
    # else:
    #     lower_index = num_procs_type1*(loc_size + 1) + (rank - num_procs_type1)*loc_size
    #     upper_index = num_procs_type1*(loc_size + 1) + (rank - num_procs_type1 + 1)*loc_size
    
    # loc_random_numbers = np.random.default_rng(rng).normal(loc=0,scale= np.sqrt(noise_variance),size=loc_size)
    # indices = np.arange(lower_index,upper_index,dtype=np.int32)
    # d.setValues(indices,loc_random_numbers,addv=True)
    # d.assemblyBegin()
    # d.assemblyEnd()


